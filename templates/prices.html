{% extends "base.html" %}

{% block title %}Stock Prices - Flask App{% endblock %}

{% block content %}

<!-- Flash Messages -->
{% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
        {% for category, message in messages %}
            <div class="alert {% if category == 'error' %}alert-error{% else %}alert-success{% endif %} mb-6">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    {% if category == 'error' %}
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    {% else %}
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    {% endif %}
                </svg>
                <span>{{ message }}</span>
            </div>
        {% endfor %}
    {% endif %}
{% endwith %}

{% if access_token %}
<div class="card bg-base-100 shadow-xl mb-6">
    <div class="card-body">
        <div class="collapse collapse-arrow">
            <input type="checkbox" id="tokenCollapse" />
            <div class="collapse-title text-lg font-medium cursor-pointer">
                <div class="flex items-center gap-2">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z"></path>
                    </svg>
                    Zerodha Tokens
                </div>
            </div>
            <div class="collapse-content">
                <div class="mt-4">
                    <h3 class="text-sm font-semibold mb-2">Access Token:</h3>
                    <div class="bg-base-200 rounded-lg p-4">
                        <code class="text-sm break-all">{{ access_token }}</code>
                    </div>
                </div>
                {% if request_token %}
                <div class="mt-4">
                    <h3 class="text-sm font-semibold mb-2">Request Token:</h3>
                    <div class="bg-base-200 rounded-lg p-4">
                        <code class="text-sm break-all">{{ request_token }}</code>
                    </div>
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endif %}

{% if prices %}
<div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
    <div class="card bg-base-100 shadow-xl hover:shadow-2xl transition-shadow">
        <div class="card-body">
            <div class="mb-4">
                <h2 class="card-title text-xl">{{ prices.nifty.name }}</h2>
            </div>
            <div class="mb-4">
                <div class="text-4xl font-bold text-primary mb-2">₹{{ "%.2f"|format(prices.nifty.current_price) }}</div>
                <div class="badge badge-lg {% if prices.nifty.change >= 0 %}badge-success{% else %}badge-error{% endif %}">
                    {% if prices.nifty.change >= 0 %}+{% endif %}{{ "%.2f"|format(prices.nifty.change) }} 
                    ({% if prices.nifty.change_percent >= 0 %}+{% endif %}{{ "%.2f"|format(prices.nifty.change_percent) }}%)
                </div>
            </div>
            <div class="text-sm text-base-content/60 italic">Last updated: {{ prices.nifty.last_updated }}</div>
        </div>
    </div>

    <div class="card bg-base-100 shadow-xl hover:shadow-2xl transition-shadow">
        <div class="card-body">
            <div class="mb-4">
                <h2 class="card-title text-xl">{{ prices.bank_nifty.name }}</h2>
            </div>
            <div class="mb-4">
                <div class="text-4xl font-bold text-success mb-2">₹{{ "%.2f"|format(prices.bank_nifty.current_price) }}</div>
                <div class="badge badge-lg {% if prices.bank_nifty.change >= 0 %}badge-success{% else %}badge-error{% endif %}">
                    {% if prices.bank_nifty.change >= 0 %}+{% endif %}{{ "%.2f"|format(prices.bank_nifty.change) }} 
                    ({% if prices.bank_nifty.change_percent >= 0 %}+{% endif %}{{ "%.2f"|format(prices.bank_nifty.change_percent) }}%)
                </div>
            </div>
            <div class="text-sm text-base-content/60 italic">Last updated: {{ prices.bank_nifty.last_updated }}</div>
        </div>
    </div>
</div>

<!-- Stock Selection Section -->
<div class="card bg-base-100 shadow-xl mb-8">
    <div class="card-body">
        <div class="flex items-center justify-between mb-4">
            <h2 class="card-title text-xl">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                </svg>
                Custom Stocks
            </h2>
        </div>
        
        <!-- Add Stock Form -->
        <div class="flex gap-2 mb-4">
            <div class="form-control flex-1">
                <label class="label">
                    <span class="label-text">Exchange</span>
                </label>
                <select id="stockExchange" class="select select-bordered">
                    <option value="NSE" selected>NSE</option>
                    <option value="BSE">BSE</option>
                    <option value="NFO">NFO</option>
                    <option value="MCX">MCX</option>
                </select>
            </div>
            <div class="form-control flex-2 relative">
                <label class="label">
                    <span class="label-text">Stock Symbol</span>
                </label>
                <div class="relative">
                    <input type="text" id="stockSymbol" class="input input-bordered w-full" placeholder="e.g., RELIANCE, TCS, INFY" autocomplete="off">
                    <div id="stockSymbolSuggestions" class="absolute z-50 w-full mt-1 bg-base-100 border border-base-300 rounded-lg shadow-lg max-h-60 overflow-auto hidden custom-scrollbar">
                        <!-- Suggestions will be populated here -->
                    </div>
                </div>
            </div>
            <div class="form-control flex-shrink-0">
                <label class="label">
                    <span class="label-text">&nbsp;</span>
                </label>
                <button id="addStockBtn" class="btn btn-primary">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                    </svg>
                    Add Stock
                </button>
            </div>
        </div>
        
        <!-- Custom Stocks Display -->
        <div id="customStocksContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <!-- Custom stocks will be dynamically added here -->
        </div>
    </div>
</div>

<!-- Sleek Refresh Control - Top Right Corner -->
<div class="fixed top-20 right-4 z-40">
    <div class="dropdown dropdown-end">
        <div tabindex="0" role="button" class="btn btn-ghost btn-sm bg-base-100/90 backdrop-blur-sm shadow-lg border border-base-300">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
            </svg>
            <span class="text-xs" id="refreshStatusCompact">5s</span>
        </div>
        <ul tabindex="0" class="dropdown-content menu p-2 shadow-xl bg-base-100 rounded-box w-48 border border-base-300">
            <li class="menu-title">
                <span>Refresh Rate</span>
            </li>
            <li><a data-rate="1000" class="refresh-option">1 second</a></li>
            <li><a data-rate="2000" class="refresh-option">2 seconds</a></li>
            <li><a data-rate="5000" class="refresh-option active">5 seconds</a></li>
            <li><a data-rate="10000" class="refresh-option">10 seconds</a></li>
            <li><a data-rate="30000" class="refresh-option">30 seconds</a></li>
            <li><a data-rate="60000" class="refresh-option">1 minute</a></li>
            <li><a data-rate="0" class="refresh-option">Manual only</a></li>
            <div class="divider my-1"></div>
            <li>
                <button id="manualRefresh" class="btn btn-primary btn-sm w-full">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    Refresh Now
                </button>
            </li>
        </ul>
    </div>
</div>

<!-- Three Levels Section -->
<div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
    <!-- Nifty 50 Levels -->
    <div class="card bg-base-100 shadow-xl">
        <div class="card-body">
            <div class="flex items-center justify-between mb-4">
                <h2 class="card-title text-xl">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                    </svg>
                    Nifty 50 Levels
                </h2>
                <div class="flex gap-2">
                    <button class="btn btn-sm btn-success" onclick="addNiftyLevel()">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                        Add Level
                    </button>
                    <button class="btn btn-sm btn-warning" onclick="clearNiftyLevels()" title="Clear all levels">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                        Clear All
                    </button>
                </div>
            </div>
            
            <div id="niftyLevelsContainer" class="space-y-3">
                <!-- Levels will be dynamically added here -->
            </div>

        </div>
    </div>

    <!-- Bank Nifty Levels -->
    <div class="card bg-base-100 shadow-xl">
        <div class="card-body">
            <div class="flex items-center justify-between mb-4">
                <h2 class="card-title text-xl">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                    </svg>
                    Bank Nifty Levels
                </h2>
                <div class="flex gap-2">
                    <button class="btn btn-sm btn-success" onclick="addBankLevel()">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                        Add Level
                    </button>
                    <button class="btn btn-sm btn-warning" onclick="clearBankLevels()" title="Clear all levels">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                        Clear All
                    </button>
                </div>
            </div>
            
            <div id="bankLevelsContainer" class="space-y-3">
                <!-- Levels will be dynamically added here -->
            </div>

        </div>
    </div>
</div>

<!-- Stock Levels Section -->
<div class="card bg-base-100 shadow-xl mb-8">
    <div class="card-body">
        <div class="flex items-center justify-between mb-4">
            <h2 class="card-title text-xl">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                </svg>
                Stock Levels
            </h2>
            <div class="flex gap-2">
                <select id="stockLevelStockSelect" class="select select-bordered select-sm">
                    <option value="">Select Stock</option>
                </select>
                <button class="btn btn-sm btn-success" onclick="addStockLevelFromSection()">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                    </svg>
                    Add Level
                </button>
            </div>
        </div>
        
        <div id="stockLevelsContainer" class="space-y-4">
            <!-- Stock levels will be dynamically added here, grouped by stock -->
        </div>
    </div>
</div>

<!-- Paper Trades Section -->
<div class="card bg-base-100 shadow-xl mb-8">
    <div class="card-body">
        <div class="flex items-center justify-between mb-4">
            <h2 class="card-title text-xl">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                Paper Trades
            </h2>
            <div class="flex items-center gap-2">
                <div class="form-control">
                    <label class="label">
                        <span class="label-text text-xs">Date Filter</span>
                    </label>
                    <input type="date" id="paperTradesDateFilter" class="input input-bordered input-sm w-40" />
                </div>
                <button id="refreshPaperTrades" class="btn btn-sm btn-primary">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    Refresh
                </button>
            </div>
        </div>
        
        <div id="paperTradesContainer" class="overflow-x-auto">
            <div class="text-center text-base-content/60 py-8">
                <svg class="w-12 h-12 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <p>Loading paper trades...</p>
            </div>
        </div>
    </div>
</div>

{% else %}
<div class="hero bg-base-100 rounded-2xl shadow-xl">
    <div class="hero-content text-center">
        <div class="max-w-md">
            <h1 class="text-3xl font-bold text-error mb-4">Unable to fetch stock prices</h1>
            <p class="text-base-content/70 mb-6">Please make sure you are logged in and try again.</p>
            <a href="{{ url_for('auth.zerodha_login') }}" class="btn btn-primary btn-lg">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1"></path>
                </svg>
                Connect to Exchange
            </a>
        </div>
    </div>
</div>
{% endif %}
{% endblock %}

{% block scripts %}
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
// Custom Stocks Management
let customStocks = []; // Array of {exchange, symbol, key}
let stockLevels = {}; // Object mapping stock key to array of levels {uuid, value}
let customStocksRefreshInterval = null; // Store interval ID for custom stocks refresh

// Load stocks from localStorage on page load
function loadCustomStocks() {
    const saved = localStorage.getItem('customStocks');
    if (saved) {
        try {
            customStocks = JSON.parse(saved);
            renderCustomStocks();
            
            // Subscribe all stocks to WebSocket when loaded
            // Wait a bit for WebSocket to connect first
            setTimeout(() => {
                customStocks.forEach(stock => {
                    subscribeStockToWebSocket(stock.exchange, stock.symbol);
                });
            }, 2000);
            
            fetchCustomStocksPrices();
        } catch (e) {
            console.error('Error loading custom stocks:', e);
            customStocks = [];
        }
    }
}

// Save stocks to localStorage
function saveCustomStocks() {
    localStorage.setItem('customStocks', JSON.stringify(customStocks));
}

// Add a stock
function addStock(exchange, symbol) {
    const key = `${exchange}:${symbol}`;
    
    // Check if already exists
    if (customStocks.some(s => s.key === key)) {
        alert('Stock already added!');
        return;
    }
    
    customStocks.push({ exchange, symbol, key });
    saveCustomStocks();
    renderCustomStocks();
    
    // Subscribe to WebSocket for real-time updates
    subscribeStockToWebSocket(exchange, symbol);
    
    // Fetch initial price (will use WebSocket for updates)
    fetchCustomStocksPrices();
    updateStockLevelSelector();
    // Restart auto-refresh interval if needed (only if WebSocket not connected)
    setupCustomStocksAutoRefresh();
}

// Subscribe a stock to WebSocket for real-time price updates
function subscribeStockToWebSocket(exchange, symbol) {
    if (!isConnected) {
        console.log(`WebSocket not connected, will subscribe ${exchange}:${symbol} when connected`);
        return;
    }
    
    fetch('/prices/api/subscribe', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ exchange, symbol })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log(`✅ Subscribed ${exchange}:${symbol} to WebSocket`);
        } else {
            console.warn(`⚠️ Failed to subscribe ${exchange}:${symbol} to WebSocket:`, data.error);
        }
    })
    .catch(error => {
        console.error(`Error subscribing ${exchange}:${symbol} to WebSocket:`, error);
    });
}

// Remove a stock
function removeStock(key) {
    customStocks = customStocks.filter(s => s.key !== key);
    // Also remove levels for this stock
    delete stockLevels[key];
    saveCustomStocks();
    renderCustomStocks();
    updateStockLevelSelector();
    renderAllStockLevels();
    // Restart auto-refresh interval (will clear if no stocks left)
    setupCustomStocksAutoRefresh();
}

// Render custom stocks UI
function renderCustomStocks() {
    const container = document.getElementById('customStocksContainer');
    if (!container) return;
    
    if (customStocks.length === 0) {
        container.innerHTML = `
            <div class="col-span-full text-center text-base-content/60 py-8">
                <svg class="w-12 h-12 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                </svg>
                <p>No custom stocks added. Add stocks using the form above.</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = customStocks.map(stock => {
        const safeKey = stock.key.replace(/:/g, '-');
        return `
        <div class="card bg-base-100 shadow-xl hover:shadow-2xl transition-shadow" id="stock-${safeKey}">
            <div class="card-body">
                <div class="flex items-center justify-between mb-2">
                    <h3 class="card-title text-lg">${stock.symbol}</h3>
                    <button class="btn btn-sm btn-ghost btn-circle" onclick="removeStock('${stock.key}')">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
                <div class="text-xs text-base-content/60 mb-2">${stock.exchange}</div>
                <div class="mb-2">
                    <div class="text-2xl font-bold text-primary" id="price-${safeKey}">Loading...</div>
                    <div class="badge badge-sm" id="change-${safeKey}">--</div>
                </div>
                <div class="text-xs text-base-content/60 italic mb-4" id="updated-${safeKey}">--</div>
                
            </div>
        </div>
    `;
    }).join('');
    
    // Load levels for each stock and render stock levels section
    customStocks.forEach(stock => {
        loadStockLevels(stock.key);
    });
    
    // Update stock selector and render stock levels section
    updateStockLevelSelector();
    renderAllStockLevels();
}

// Fetch prices for all custom stocks
function fetchCustomStocksPrices() {
    // Early return if no stocks to avoid unnecessary API calls
    if (!customStocks || customStocks.length === 0) {
        return;
    }
    
    const stocks = customStocks.map(s => `${s.exchange}:${s.symbol}`);
    
    // Only make API call if we have stocks
    if (stocks.length === 0) {
        return;
    }
    
    fetch('/prices/api/quotes', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ stocks })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success && data.prices) {
            // Update each stock card
            customStocks.forEach(stock => {
                const key = stock.key;
                const priceData = data.prices[key];
                
                if (priceData) {
                    updateStockCard(stock.key, priceData);
                } else {
                    updateStockCardError(stock.key, 'Price not available');
                }
            });
        } else if (data.error) {
            // Handle rate limit errors
            if (data.error.includes('Too many requests') || data.error.includes('rate limit')) {
                console.warn('Rate limit detected for custom stocks, temporarily stopping polling');
                // Stop polling temporarily
                if (customStocksRefreshInterval) {
                    clearInterval(customStocksRefreshInterval);
                    customStocksRefreshInterval = null;
                    // Restart after 60 seconds
                    setTimeout(() => {
                        setupCustomStocksAutoRefresh();
                    }, 60000);
                }
                // Show error on all stocks
                customStocks.forEach(stock => {
                    updateStockCardError(stock.key, 'Rate limited - retrying in 60s');
                });
            } else {
                customStocks.forEach(stock => {
                    updateStockCardError(stock.key, data.error || 'Error fetching price');
                });
            }
        }
    })
    .catch(error => {
        console.error('Error fetching custom stocks prices:', error);
        customStocks.forEach(stock => {
            updateStockCardError(stock.key, 'Error fetching price');
        });
    });
}

// Setup or clear the auto-refresh interval for custom stocks
function setupCustomStocksAutoRefresh() {
    // Clear existing interval if any
    if (customStocksRefreshInterval) {
        clearInterval(customStocksRefreshInterval);
        customStocksRefreshInterval = null;
    }
    
    // Only set up interval if there are custom stocks AND WebSocket is not connected
    // Custom stocks should use WebSocket when available to avoid rate limits
    if (customStocks && customStocks.length > 0 && !isConnected) {
        // Use longer interval to avoid rate limits (30 seconds)
        // Only poll if WebSocket is not working
        customStocksRefreshInterval = setInterval(() => {
            // Skip if WebSocket is now connected
            if (isConnected) {
                if (customStocksRefreshInterval) {
                    clearInterval(customStocksRefreshInterval);
                    customStocksRefreshInterval = null;
                }
                return;
            }
            
            // Double-check stocks still exist before making API call
            if (customStocks && customStocks.length > 0) {
                fetchCustomStocksPrices();
                // Also update level displays (without re-rendering, which would reset unsaved inputs)
                customStocks.forEach(stock => {
                    if (stockLevels[stock.key]) {
                        stockLevels[stock.key].forEach(level => {
                            updateStockLevelDisplay(stock.key, level.uuid);
                        });
                    }
                });
            } else {
                // No stocks, clear the interval
                if (customStocksRefreshInterval) {
                    clearInterval(customStocksRefreshInterval);
                    customStocksRefreshInterval = null;
                }
            }
        }, 30000); // Poll every 30 seconds to avoid rate limits (only when WebSocket is not available)
    }
}


// Update stock card with error
function updateStockCardError(key, message) {
    const safeKey = key.replace(/:/g, '-');
    const priceEl = document.getElementById(`price-${safeKey}`);
    const changeEl = document.getElementById(`change-${safeKey}`);
    
    if (priceEl) priceEl.textContent = message;
    if (changeEl) {
        changeEl.textContent = 'N/A';
        changeEl.className = 'badge badge-sm badge-warning';
    }
}

// Stock Levels Management
function addStockLevel(stockKey) {
    if (!stockLevels[stockKey]) {
        stockLevels[stockKey] = [];
    }
    
    const levelUuid = 'temp_' + Date.now();
    stockLevels[stockKey].push({
        uuid: levelUuid, 
        value: null,
        stop_loss: null,
        target_percentage: null
    });
    renderAllStockLevels();
}

function addStockLevelFromSection() {
    const select = document.getElementById('stockLevelStockSelect');
    const stockKey = select.value;
    
    if (!stockKey) {
        alert('Please select a stock first');
        return;
    }
    
    addStockLevel(stockKey);
}

function updateStockLevelSelector() {
    const select = document.getElementById('stockLevelStockSelect');
    if (!select) return;
    
    // Clear existing options except the first one
    select.innerHTML = '<option value="">Select Stock</option>';
    
    // Add all custom stocks
    customStocks.forEach(stock => {
        const option = document.createElement('option');
        option.value = stock.key;
        option.textContent = `${stock.symbol} (${stock.exchange})`;
        select.appendChild(option);
    });
}

function renderAllStockLevels(selectedStockKey = null) {
    const container = document.getElementById('stockLevelsContainer');
    if (!container) return;
    
    // Preserve current input values before re-rendering
    const preservedValues = {};
    customStocks.forEach(stock => {
        if (stockLevels[stock.key]) {
            const safeKey = stock.key.replace(/:/g, '-');
            stockLevels[stock.key].forEach(level => {
                const inputId = `stockLevelInput_${safeKey}_${level.uuid}`;
                const stopLossId = `stockStopLoss_${safeKey}_${level.uuid}`;
                const targetId = `stockTarget_${safeKey}_${level.uuid}`;
                
                const inputEl = document.getElementById(inputId);
                const stopLossEl = document.getElementById(stopLossId);
                const targetEl = document.getElementById(targetId);
                
                if (inputEl && inputEl.value !== '') {
                    preservedValues[inputId] = inputEl.value;
                }
                if (stopLossEl && stopLossEl.value !== '') {
                    preservedValues[stopLossId] = stopLossEl.value;
                }
                if (targetEl && targetEl.value !== '') {
                    preservedValues[targetId] = targetEl.value;
                }
            });
        }
    });
    
    // If no stock key provided, check the dropdown for current selection
    if (selectedStockKey === null) {
        const select = document.getElementById('stockLevelStockSelect');
        if (select && select.value) {
            selectedStockKey = select.value;
        }
    }
    
    // Get all stocks that have levels
    let stocksWithLevels = customStocks.filter(stock => 
        stockLevels[stock.key] && stockLevels[stock.key].length > 0
    );
    
    // Filter by selected stock if one is selected
    if (selectedStockKey) {
        stocksWithLevels = stocksWithLevels.filter(stock => stock.key === selectedStockKey);
    }
    
    if (stocksWithLevels.length === 0) {
        if (selectedStockKey) {
            container.innerHTML = '<div class="text-center text-base-content/60 py-4">No levels found for the selected stock. Add levels using the form above.</div>';
        } else {
            container.innerHTML = '<div class="text-center text-base-content/60 py-4">No stock levels added. Add stocks and create levels using the form above.</div>';
        }
        return;
    }
    
    // Render levels grouped by stock
    container.innerHTML = stocksWithLevels.map(stock => {
        const safeKey = stock.key.replace(/:/g, '-');
        return `
            <div class="border border-base-300 rounded-lg p-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="font-semibold text-lg">${stock.symbol} <span class="text-sm text-base-content/60">(${stock.exchange})</span></h3>
                    <button class="btn btn-xs btn-ghost" onclick="removeAllStockLevels('${stock.key}')" title="Clear all levels for this stock">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    </button>
                </div>
                <div class="space-y-2">
                    ${stockLevels[stock.key].map(level => `
                        <div class="border border-base-300 rounded-lg p-2">
                            <div class="flex items-center gap-2">
                                <div class="flex-1">
                                    <label class="text-xs text-base-content/60 mb-1 block">Entry</label>
                                    <input type="number" id="stockLevelInput_${safeKey}_${level.uuid}" 
                                           placeholder="Entry price" 
                                           class="input input-bordered input-xs w-full" 
                                           step="0.01" 
                                           value="${level.value || ''}">
                                </div>
                                <div class="flex-1">
                                    <label class="text-xs text-base-content/60 mb-1 block">SL %</label>
                                    <input type="number" id="stockStopLoss_${safeKey}_${level.uuid}" 
                                           placeholder="Stop Loss %" 
                                           class="input input-bordered input-xs w-full" 
                                           step="0.1" 
                                           value="${level.stop_loss || ''}">
                                </div>
                                <div class="flex-1">
                                    <label class="text-xs text-base-content/60 mb-1 block">Tgt %</label>
                                    <input type="number" id="stockTarget_${safeKey}_${level.uuid}" 
                                           placeholder="Target %" 
                                           class="input input-bordered input-xs w-full" 
                                           step="0.1" 
                                           value="${level.target_percentage || ''}">
                                </div>
                                <div class="flex gap-1 pt-5">
                                    <button class="btn btn-primary btn-xs px-2" onclick="setStockLevel('${stock.key}', '${level.uuid}')" title="Save">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                        </svg>
                                    </button>
                                    <button class="btn btn-error btn-xs px-2" onclick="removeStockLevel('${stock.key}', '${level.uuid}')" title="Delete">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div class="flex items-center gap-2 text-xs mt-2" id="stockLevelInfo_${safeKey}_${level.uuid}">
                                <div class="flex-1 text-gray-600" id="stockLevelStatus_${safeKey}_${level.uuid}">
                                    ${level.value ? `Entry: ₹${level.value.toFixed(2)}` : 'Not set'}
                                </div>
                                <div class="text-gray-500" id="stockLevelDistance_${safeKey}_${level.uuid}"></div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }).join('');
    
    // Restore preserved input values after re-rendering
    Object.keys(preservedValues).forEach(inputId => {
        const inputEl = document.getElementById(inputId);
        if (inputEl) {
            inputEl.value = preservedValues[inputId];
        }
    });
    
    // Update displays for all levels
    stocksWithLevels.forEach(stock => {
        stockLevels[stock.key].forEach(level => {
            updateStockLevelDisplay(stock.key, level.uuid);
        });
    });
}

function removeAllStockLevels(stockKey) {
    if (!confirm(`Are you sure you want to clear all levels for this stock?`)) {
        return;
    }
    
    if (!stockLevels[stockKey] || stockLevels[stockKey].length === 0) {
        return;
    }
    
    // Delete all levels from database
    const deletePromises = stockLevels[stockKey]
        .filter(level => !level.uuid.startsWith('temp_'))
        .map(level => 
            fetch(`/levels/delete/${level.uuid}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
        );
    
    Promise.all(deletePromises)
        .then(() => {
            stockLevels[stockKey] = [];
            renderAllStockLevels();
        })
        .catch(error => {
            console.error('Error clearing stock levels:', error);
            alert('Error clearing levels');
        });
}

function removeStockLevel(stockKey, uuid) {
    if (!stockLevels[stockKey]) return;
    
    const levelIndex = stockLevels[stockKey].findIndex(l => l.uuid === uuid);
    if (levelIndex === -1) return;
    
    const level = stockLevels[stockKey][levelIndex];
    
    if (!level.value || uuid.startsWith('temp_')) {
        // Just remove from array if not saved yet
        stockLevels[stockKey].splice(levelIndex, 1);
        renderAllStockLevels();
        return;
    }
    
    if (confirm(`Are you sure you want to delete this level (₹${level.value.toFixed(2)})?`)) {
        // Call delete API
        fetch(`/levels/delete/${uuid}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                stockLevels[stockKey].splice(levelIndex, 1);
                renderAllStockLevels();
                console.log('Stock level deleted successfully');
            } else {
                alert('Error deleting level: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error deleting level: ' + error.message);
        });
    }
}

function setStockLevel(stockKey, uuid) {
    if (!stockLevels[stockKey]) return;
    
    const levelIndex = stockLevels[stockKey].findIndex(l => l.uuid === uuid);
    if (levelIndex === -1) return;
    
    const safeKey = stockKey.replace(/:/g, '-');
    const input = document.getElementById(`stockLevelInput_${safeKey}_${uuid}`);
    const stopLossInput = document.getElementById(`stockStopLoss_${safeKey}_${uuid}`);
    const targetInput = document.getElementById(`stockTarget_${safeKey}_${uuid}`);
    
    const value = parseFloat(input.value);
    const stopLossPercentage = stopLossInput.value ? parseFloat(stopLossInput.value) : null;
    const targetPercentage = targetInput.value ? parseFloat(targetInput.value) : null;
    
    if (isNaN(value) || value <= 0) {
        alert('Please enter a valid positive entry price');
        return;
    }
    
    if (stopLossPercentage !== null && (isNaN(stopLossPercentage) || stopLossPercentage <= 0)) {
        alert('Please enter a valid positive stop loss percentage');
        return;
    }
    
    if (targetPercentage !== null && (isNaN(targetPercentage) || targetPercentage <= 0)) {
        alert('Please enter a valid positive target percentage');
        return;
    }
    
    const existingUuid = stockLevels[stockKey][levelIndex].uuid.startsWith('temp_') ? null : stockLevels[stockKey][levelIndex].uuid;
    stockLevels[stockKey][levelIndex].value = value;
    stockLevels[stockKey][levelIndex].stop_loss = stopLossPercentage;
    stockLevels[stockKey][levelIndex].target_percentage = targetPercentage;
    
    // Get stock info
    const stock = customStocks.find(s => s.key === stockKey);
    if (!stock) return;
    
    // Save to database
    saveStockLevelToDatabase(stockKey, stock.exchange, stock.symbol, value, existingUuid, stopLossPercentage, targetPercentage)
        .then((data) => {
            if (data && data.uuid) {
                stockLevels[stockKey][levelIndex].uuid = data.uuid;
            }
            console.log(`Stock level set: Entry=${value}, SL=${stopLossPercentage}%, Tgt=${targetPercentage}%`);
            renderAllStockLevels();
            updateStockLevelDisplays(stockKey);
        })
        .catch(error => {
            alert('Error saving level: ' + error.message);
        });
}

function saveStockLevelToDatabase(stockKey, exchange, symbol, levelValue, levelUuid = null, stopLossPercentage = null, targetPercentage = null) {
    return fetch('/levels/save', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            index_type: stockKey,  // Use full key as index_type
            level_value: levelValue,
            uuid: levelUuid,
            stock_symbol: stockKey,
            stock_exchange: exchange,
            stop_loss: stopLossPercentage,
            target_percentage: targetPercentage
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Stock level saved to database:', data.uuid);
            return data;
        } else {
            console.error('Error saving stock level:', data.error);
            throw new Error(data.error || 'Failed to save level');
        }
    })
    .catch(error => {
        console.error('Error saving stock level:', error);
        throw error;
    });
}

function loadStockLevels(stockKey) {
    fetch(`/levels/get?stock_symbol=${encodeURIComponent(stockKey)}`)
        .then(response => response.json())
        .then(data => {
            if (data.success && Array.isArray(data.levels)) {
                stockLevels[stockKey] = data.levels.map(level => ({
                    uuid: level.uuid,
                    value: level.level_value || level.value,  // Support both formats
                    stop_loss: level.stop_loss || null,
                    target_percentage: level.target_percentage || null
                }));
                console.log(`Loaded ${data.levels.length} levels for ${stockKey}:`, stockLevels[stockKey]);
                renderAllStockLevels();
                updateStockLevelDisplays(stockKey);
            } else {
                console.log(`No levels found for ${stockKey}`, data);
                stockLevels[stockKey] = [];
                renderAllStockLevels();
            }
        })
        .catch(error => {
            console.error('Error loading stock levels:', error);
            stockLevels[stockKey] = [];
            renderAllStockLevels();
        });
}


function updateStockLevelDisplay(stockKey, uuid) {
    const safeKey = stockKey.replace(/:/g, '-');
    const level = stockLevels[stockKey]?.find(l => l.uuid === uuid);
    if (!level) return;
    
    const statusElement = document.getElementById(`stockLevelStatus_${safeKey}_${uuid}`);
    const distanceElement = document.getElementById(`stockLevelDistance_${safeKey}_${uuid}`);
    
    if (!statusElement || !distanceElement) return;
    
    // Get current price
    const priceEl = document.getElementById(`price-${safeKey}`);
    const currentPrice = priceEl ? parseFloat(priceEl.textContent.replace(/[₹,]/g, '')) : 0;
    
    if (level.value !== null) {
        let statusText = `Entry: ₹${level.value.toFixed(2)}`;
        if (level.stop_loss) {
            const stopLossPrice = level.value * (1 - level.stop_loss / 100);
            statusText += ` | SL: ₹${stopLossPrice.toFixed(2)} (${level.stop_loss}%)`;
        }
        if (level.target_percentage) {
            const targetPrice = level.value * (1 + level.target_percentage / 100);
            statusText += ` | Tgt: ₹${targetPrice.toFixed(2)} (${level.target_percentage}%)`;
        }
        statusElement.textContent = statusText;
        statusElement.className = 'text-xs text-gray-600';
        
        if (currentPrice > 0 && !isNaN(currentPrice)) {
            const distance = Math.abs(currentPrice - level.value);
            const distancePercent = (distance / level.value) * 100;
            distanceElement.textContent = `Distance: ₹${distance.toFixed(2)} (${distancePercent.toFixed(1)}%)`;
            
            // Color code based on distance
            if (distancePercent <= 1) {
                distanceElement.className = 'text-xs text-error font-semibold';
            } else if (distancePercent <= 5) {
                distanceElement.className = 'text-xs text-warning font-semibold';
            } else {
                distanceElement.className = 'text-xs text-gray-500';
            }
        } else {
            distanceElement.textContent = '';
        }
    } else {
        statusElement.textContent = 'Not set';
        statusElement.className = 'text-xs text-gray-600';
        distanceElement.textContent = '';
    }
}

function updateStockLevelDisplays(stockKey) {
    if (!stockLevels[stockKey]) return;
    stockLevels[stockKey].forEach(level => {
        updateStockLevelDisplay(stockKey, level.uuid);
    });
}

// Update stock level displays when price updates
function updateStockCard(key, priceData) {
    const safeKey = key.replace(/:/g, '-');
    const priceEl = document.getElementById(`price-${safeKey}`);
    const changeEl = document.getElementById(`change-${safeKey}`);
    const updatedEl = document.getElementById(`updated-${safeKey}`);
    
    if (priceEl) {
        priceEl.textContent = `₹${parseFloat(priceData.current_price || 0).toFixed(2)}`;
    }
    
    if (changeEl) {
        const change = parseFloat(priceData.change || 0);
        const changePercent = parseFloat(priceData.change_percent || 0);
        changeEl.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
        changeEl.className = `badge badge-sm ${change >= 0 ? 'badge-success' : 'badge-error'}`;
    }
    
    if (updatedEl && priceData.last_updated) {
        updatedEl.textContent = `Last updated: ${priceData.last_updated}`;
    }
    
    // Update level displays for this stock
    updateStockLevelDisplays(key);
}

// Initialize SocketIO connection for continuous price streaming
const socket = io();

// Connection status
let isConnected = false;
let lastPriceUpdateTime = null;
let fallbackPollingInterval = null;
let priceUpdateCheckInterval = null;

socket.on('connect', function() {
    console.log('Connected to WebSocket server');
    isConnected = true;
    updateConnectionStatus(true);
    lastPriceUpdateTime = Date.now();
    
    // Stop REST API polling for custom stocks when WebSocket is connected
    if (customStocksRefreshInterval) {
        clearInterval(customStocksRefreshInterval);
        customStocksRefreshInterval = null;
        console.log('Stopped REST API polling for custom stocks - WebSocket is connected');
    }
    
    // Subscribe all custom stocks to WebSocket
    if (customStocks && customStocks.length > 0) {
        console.log('Subscribing custom stocks to WebSocket...');
        customStocks.forEach(stock => {
            subscribeStockToWebSocket(stock.exchange, stock.symbol);
        });
    }
    
    // Start monitoring for price updates
    startPriceUpdateMonitoring();
});

socket.on('disconnect', function() {
    console.log('Disconnected from WebSocket server');
    isConnected = false;
    updateConnectionStatus(false);
    // Start fallback polling when WebSocket disconnects
    startFallbackPolling();
    
    // Stop monitoring
    if (priceUpdateCheckInterval) {
        clearInterval(priceUpdateCheckInterval);
        priceUpdateCheckInterval = null;
    }
});

socket.on('connected', function(data) {
    console.log('WebSocket handshake complete:', data);
});

socket.on('error', function(error) {
    console.error('WebSocket error:', error);
    isConnected = false;
    updateConnectionStatus(false);
    startFallbackPolling();
});

// Listen for continuous price updates
socket.on('price_update', function(data) {
    console.log('Received price update:', data);
    lastPriceUpdateTime = Date.now();
    
    // Update Nifty data if available
    if (data.nifty) {
        updatePriceCard('nifty', data.nifty);
        if (data.nifty.current_price) {
            updateNiftyPrice(data.nifty.current_price);
        }
    }
    
    // Update Bank Nifty data if available
    if (data.bank_nifty) {
        updatePriceCard('bank_nifty', data.bank_nifty);
        if (data.bank_nifty.current_price) {
            updateBankNiftyPrice(data.bank_nifty.current_price);
        }
    }
    
    // Update custom stocks if available (when WebSocket supports custom stocks)
    if (data.custom_stocks && typeof data.custom_stocks === 'object') {
        Object.keys(data.custom_stocks).forEach(key => {
            const priceData = data.custom_stocks[key];
            if (priceData) {
                updateStockCard(key, priceData);
            }
        });
    }
});

// Monitor if we're receiving price updates
function startPriceUpdateMonitoring() {
    // Clear existing interval if any
    if (priceUpdateCheckInterval) {
        clearInterval(priceUpdateCheckInterval);
        priceUpdateCheckInterval = null;
    }
    
    // Check every 10 seconds if we're receiving updates
    priceUpdateCheckInterval = setInterval(() => {
        if (isConnected) {
            const timeSinceLastUpdate = Date.now() - (lastPriceUpdateTime || 0);
            // If no update received in 15 seconds, start fallback polling
            if (timeSinceLastUpdate > 15000) {
                console.warn('No price updates received in 15 seconds, starting fallback polling');
                startFallbackPolling();
            }
        }
    }, 10000);
}

function updateConnectionStatus(connected) {
    const statusElement = document.getElementById('refreshStatusCompact');
    if (statusElement) {
        if (connected) {
            statusElement.textContent = 'Live';
            statusElement.parentElement.classList.add('text-success');
        } else {
            statusElement.textContent = 'Offline';
            statusElement.parentElement.classList.remove('text-success');
        }
    }
}

// Legacy refresh function (kept for manual refresh button)
function refreshPrices(showButtonState = false) {
    // Show loading state only for manual refreshes
    let refreshBtn = null;
    let originalText = '';
    
    if (showButtonState) {
        refreshBtn = document.querySelector('.btn-primary');
        originalText = refreshBtn.textContent;
        refreshBtn.textContent = 'Refreshing...';
        refreshBtn.disabled = true;
    }
    
    // Make AJAX call to fetch fresh data
    fetch('/prices/api/fetch')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            if (!data.success || data.error) {
                throw new Error(data.error || 'Failed to fetch prices');
            }
            
            // Update Nifty data
            if (data.prices && data.prices.nifty) {
                updatePriceCard('nifty', data.prices.nifty);
            }
            
            // Update Bank Nifty data
            if (data.prices && data.prices.bank_nifty) {
                updatePriceCard('bank_nifty', data.prices.bank_nifty);
            }
            
            console.log('Prices updated successfully');
        })
        .catch(error => {
            console.error('Error refreshing prices:', error);
            if (showButtonState) {
                alert('Error refreshing prices: ' + error.message);
            }
        })
        .finally(() => {
            // Reset button state only for manual refreshes
            if (showButtonState && refreshBtn) {
                refreshBtn.textContent = originalText;
                refreshBtn.disabled = false;
            }
        });
}


function updatePriceCard(type, data) {
    const card = document.querySelector(`.grid > div:nth-child(${type === 'nifty' ? '1' : '2'})`);
    if (!card) {
        console.warn(`Card not found for type: ${type}`);
        return;
    }
    
    // Update price
    const priceElement = card.querySelector('.text-4xl');
    if (priceElement && data.current_price !== undefined) {
        priceElement.textContent = `₹${parseFloat(data.current_price).toFixed(2)}`;
    }
    
    // Update change and percentage
    const changeElement = card.querySelector('.badge');
    if (changeElement) {
        const change = data.change !== undefined ? parseFloat(data.change) : 0;
        const changePercent = data.change_percent !== undefined ? parseFloat(data.change_percent) : 0;
        
        // Check if values are valid numbers
        if (!isNaN(change) && !isNaN(changePercent)) {
            changeElement.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
        } else {
            // Fallback: calculate from current_price and previous_close if available
            const currentPrice = parseFloat(data.current_price);
            const previousClose = data.previous_close ? parseFloat(data.previous_close) : null;
            
            if (!isNaN(currentPrice) && previousClose && previousClose > 0) {
                const calculatedChange = currentPrice - previousClose;
                const calculatedChangePercent = (calculatedChange / previousClose) * 100;
                changeElement.textContent = `${calculatedChange >= 0 ? '+' : ''}${calculatedChange.toFixed(2)} (${calculatedChangePercent >= 0 ? '+' : ''}${calculatedChangePercent.toFixed(2)}%)`;
            } else {
                changeElement.textContent = 'N/A';
            }
        }
        
        // Update change class for styling
        const changeValue = !isNaN(change) ? change : (data.current_price && data.previous_close ? parseFloat(data.current_price) - parseFloat(data.previous_close) : 0);
        changeElement.className = `badge badge-lg ${changeValue >= 0 ? 'badge-success' : 'badge-error'}`;
    }
    
    // Update last updated time
    const lastUpdatedElement = card.querySelector('.text-base-content\\/60');
    if (lastUpdatedElement && data.last_updated) {
        lastUpdatedElement.textContent = `Last updated: ${data.last_updated}`;
    }
}

// Function to update refresh status display
function updateRefreshStatus() {
    const statusElement = document.getElementById('refreshStatusCompact');
    if (statusElement) {
        if (isConnected) {
            statusElement.textContent = 'Live';
        } else {
            statusElement.textContent = 'Connecting...';
        }
    }
    
    // Update active state in dropdown (disabled for WebSocket mode)
    document.querySelectorAll('.refresh-option').forEach(option => {
        option.classList.remove('active');
    });
}

// Initialize - WebSocket connection is automatic
updateRefreshStatus();


// Function to fetch current price for three levels (fallback if WebSocket fails)
function fetchCurrentPrice() {
    // Prices are automatically updated via WebSocket, but we can fetch once on load if WebSocket fails
    // Only fetch if WebSocket is not connected after a reasonable timeout
    setTimeout(() => {
        if (!isConnected) {
            console.log('WebSocket not connected, using fallback fetch');
            fetch('/prices/api/fetch')
                .then(response => response.json())
                .then(data => {
                    if (!data.success || data.error) {
                        console.error('Error fetching prices:', data.error || 'Unknown error');
                        return;
                    }
                    
                    // Update Bank Nifty price and levels
                    if (data.prices && data.prices.bank_nifty && data.prices.bank_nifty.current_price) {
                        updateBankNiftyPrice(data.prices.bank_nifty.current_price);
                        updatePriceCard('bank_nifty', data.prices.bank_nifty);
                    }
                    
                    // Update Nifty 50 price and levels
                    if (data.prices && data.prices.nifty && data.prices.nifty.current_price) {
                        updateNiftyPrice(data.prices.nifty.current_price);
                        updatePriceCard('nifty', data.prices.nifty);
                    }
                })
                .catch(error => {
                    console.error('Error fetching current price for three levels:', error);
                });
        } else {
            console.log('WebSocket connected, using real-time updates');
        }
    }, 2000); // Wait 2 seconds for WebSocket to connect
}

// Function to refresh three levels independently (now handled by WebSocket)
function refreshThreeLevels() {
    // WebSocket automatically updates prices via price_update events
    // Only use fallback if WebSocket is not connected
    if (!isConnected) {
        fetchCurrentPrice();
    }
}

// Start fallback polling when WebSocket is not available or not receiving updates
function startFallbackPolling() {
    // Don't start if already polling
    if (fallbackPollingInterval) {
        return;
    }
    
    // Don't poll if WebSocket is connected and receiving updates
    if (isConnected && lastPriceUpdateTime && (Date.now() - lastPriceUpdateTime) < 10000) {
        console.log('WebSocket is working, skipping fallback polling');
        return;
    }
    
    console.log('Starting fallback polling for prices (15 second interval to avoid rate limits)');
    fallbackPollingInterval = setInterval(() => {
        // Skip if WebSocket is working
        if (isConnected && lastPriceUpdateTime && (Date.now() - lastPriceUpdateTime) < 10000) {
            return;
        }
        
        // Fetch prices via API as fallback
        fetch('/prices/api/fetch')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success && data.prices) {
                    // Update last update time if we got data
                    lastPriceUpdateTime = Date.now();
                    
                    // Update Nifty data
                    if (data.prices.nifty) {
                        updatePriceCard('nifty', data.prices.nifty);
                        if (data.prices.nifty.current_price) {
                            updateNiftyPrice(data.prices.nifty.current_price);
                        }
                    }
                    
                    // Update Bank Nifty data
                    if (data.prices.bank_nifty) {
                        updatePriceCard('bank_nifty', data.prices.bank_nifty);
                        if (data.prices.bank_nifty.current_price) {
                            updateBankNiftyPrice(data.prices.bank_nifty.current_price);
                        }
                    }
                } else {
                    console.warn('Failed to fetch prices:', data.error || 'Unknown error');
                    // If rate limited, increase interval
                    if (data.error && data.error.includes('Too many requests')) {
                        console.warn('Rate limit detected, stopping polling temporarily');
                        if (fallbackPollingInterval) {
                            clearInterval(fallbackPollingInterval);
                            fallbackPollingInterval = null;
                            // Restart after 60 seconds
                            setTimeout(() => {
                                startFallbackPolling();
                            }, 60000);
                        }
                    }
                }
            })
            .catch(error => {
                console.error('Error in fallback polling:', error);
            });
    }, 15000); // Poll every 15 seconds to avoid rate limits
}


// Event listeners for refresh controls (disabled - using WebSocket)
document.querySelectorAll('.refresh-option').forEach(option => {
    option.addEventListener('click', function(e) {
        e.preventDefault();
        // Show message that WebSocket is being used
        alert('Using continuous WebSocket streaming. Prices update automatically in real-time.');
        
        // Close dropdown
        document.querySelector('[tabindex="0"]').blur();
    });
});

document.getElementById('manualRefresh').addEventListener('click', function() {
    const button = this;
    const originalText = button.innerHTML;
    
    // Show loading state
    button.innerHTML = `
        <svg class="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        Refreshing...
    `;
    button.disabled = true;
    
    // Perform refresh
    refreshPrices(true);
    refreshThreeLevels(); // Refresh three levels independently
    
    // Reset button after a short delay
    setTimeout(() => {
        button.innerHTML = originalText;
        button.disabled = false;
    }, 1000);
});

// Initialize the form on page load
document.addEventListener('DOMContentLoaded', function() {
    // Load levels from database
    // Use a small delay to ensure DOM is fully ready
    setTimeout(() => {
        loadLevelsFromDatabase(false); // Load all levels
    }, 100);
    
    // Immediately fetch prices on page load
    console.log('Fetching initial prices on page load');
    fetch('/prices/api/fetch')
        .then(response => response.json())
        .then(data => {
            if (data.success && data.prices) {
                // Update Nifty data
                if (data.prices.nifty) {
                    updatePriceCard('nifty', data.prices.nifty);
                    if (data.prices.nifty.current_price) {
                        updateNiftyPrice(data.prices.nifty.current_price);
                    }
                }
                
                // Update Bank Nifty data
                if (data.prices.bank_nifty) {
                    updatePriceCard('bank_nifty', data.prices.bank_nifty);
                    if (data.prices.bank_nifty.current_price) {
                        updateBankNiftyPrice(data.prices.bank_nifty.current_price);
                    }
                }
                console.log('Initial prices loaded successfully');
            }
        })
        .catch(error => {
            console.error('Error fetching initial prices:', error);
        });
    
    // Start fallback polling immediately (will work alongside WebSocket if connected)
    // This ensures prices always refresh even if WebSocket has issues
    // Start fallback polling only if WebSocket doesn't connect or isn't receiving updates
    // Wait a bit to see if WebSocket connects and starts receiving updates
    setTimeout(() => {
        if (!isConnected || !lastPriceUpdateTime || (Date.now() - (lastPriceUpdateTime || 0)) > 10000) {
            console.log('WebSocket not working, starting fallback polling');
            startFallbackPolling();
        } else {
            console.log('WebSocket is working, skipping fallback polling');
        }
    }, 5000); // Wait 5 seconds to see if WebSocket works
    
    // Initialize custom stocks
    loadCustomStocks();
    
    // Set up auto-refresh for custom stocks (only if stocks exist)
    setupCustomStocksAutoRefresh();
    
    // Add stock button handler
    const addStockBtn = document.getElementById('addStockBtn');
    const stockSymbolInput = document.getElementById('stockSymbol');
    
    if (addStockBtn) {
        addStockBtn.addEventListener('click', function() {
            const exchange = document.getElementById('stockExchange').value;
            const symbol = stockSymbolInput.value.trim().toUpperCase();
            
            if (!symbol) {
                alert('Please enter a stock symbol');
                return;
            }
            
            addStock(exchange, symbol);
            stockSymbolInput.value = ''; // Clear input
        });
    }
    
    // Allow Enter key to add stock
    if (stockSymbolInput) {
        stockSymbolInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                // If suggestions are visible and one is selected, use that instead
                const suggestionsDiv = document.getElementById('stockSymbolSuggestions');
                const selected = suggestionsDiv?.querySelector('.suggestion-item.active');
                if (selected && !suggestionsDiv.classList.contains('hidden')) {
                    e.preventDefault();
                    selected.click();
                    return;
                }
                addStockBtn.click();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                const suggestionsDiv = document.getElementById('stockSymbolSuggestions');
                if (!suggestionsDiv.classList.contains('hidden')) {
                    const items = suggestionsDiv.querySelectorAll('.suggestion-item');
                    const active = suggestionsDiv.querySelector('.suggestion-item.active');
                    if (active) {
                        active.classList.remove('active');
                        const next = active.nextElementSibling;
                        if (next) {
                            next.classList.add('active');
                            next.scrollIntoView({ block: 'nearest' });
                        }
                    } else if (items.length > 0) {
                        items[0].classList.add('active');
                    }
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                const suggestionsDiv = document.getElementById('stockSymbolSuggestions');
                if (!suggestionsDiv.classList.contains('hidden')) {
                    const active = suggestionsDiv.querySelector('.suggestion-item.active');
                    if (active) {
                        active.classList.remove('active');
                        const prev = active.previousElementSibling;
                        if (prev) {
                            prev.classList.add('active');
                            prev.scrollIntoView({ block: 'nearest' });
                        }
                    }
                }
            } else if (e.key === 'Escape') {
                const suggestionsDiv = document.getElementById('stockSymbolSuggestions');
                suggestionsDiv?.classList.add('hidden');
            }
        });
        
        // Autocomplete functionality
        let searchTimeout = null;
        stockSymbolInput.addEventListener('input', function() {
            const query = this.value.trim();
            const exchange = document.getElementById('stockExchange').value;
            const suggestionsDiv = document.getElementById('stockSymbolSuggestions');
            
            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            // Hide suggestions if query is too short
            if (query.length < 2) {
                suggestionsDiv.classList.add('hidden');
                return;
            }
            
            // Debounce search (wait 300ms after user stops typing)
            searchTimeout = setTimeout(() => {
                fetch(`/prices/api/search?q=${encodeURIComponent(query)}&exchange=${encodeURIComponent(exchange)}&limit=10`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.instruments && data.instruments.length > 0) {
                            // Render suggestions
                            suggestionsDiv.innerHTML = data.instruments.map(instrument => {
                                const symbol = instrument.tradingsymbol;
                                const name = instrument.name || '';
                                const type = instrument.instrument_type || 'EQ';
                                return `
                                    <div class="suggestion-item px-4 py-2 hover:bg-base-200 cursor-pointer border-b border-base-300 last:border-b-0" 
                                         data-symbol="${symbol}" 
                                         data-exchange="${instrument.exchange}">
                                        <div class="font-semibold text-sm">${symbol}</div>
                                        ${name ? `<div class="text-xs text-base-content/60">${name} (${type})</div>` : ''}
                                    </div>
                                `;
                            }).join('');
                            
                            // Add click handlers
                            suggestionsDiv.querySelectorAll('.suggestion-item').forEach(item => {
                                item.addEventListener('click', function() {
                                    const symbol = this.getAttribute('data-symbol');
                                    const exchange = this.getAttribute('data-exchange');
                                    stockSymbolInput.value = symbol;
                                    document.getElementById('stockExchange').value = exchange;
                                    suggestionsDiv.classList.add('hidden');
                                    // Optionally auto-add the stock
                                    // addStock(exchange, symbol);
                                });
                                
                                item.addEventListener('mouseenter', function() {
                                    suggestionsDiv.querySelectorAll('.suggestion-item').forEach(i => i.classList.remove('active'));
                                    this.classList.add('active');
                                });
                            });
                            
                            suggestionsDiv.classList.remove('hidden');
                        } else {
                            suggestionsDiv.innerHTML = '<div class="px-4 py-2 text-sm text-base-content/60">No results found</div>';
                            suggestionsDiv.classList.remove('hidden');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching suggestions:', error);
                        suggestionsDiv.classList.add('hidden');
                    });
            }, 300);
        });
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            const suggestionsDiv = document.getElementById('stockSymbolSuggestions');
            if (suggestionsDiv && !suggestionsDiv.contains(e.target) && e.target !== stockSymbolInput) {
                suggestionsDiv.classList.add('hidden');
            }
        });
        
        // Update suggestions when exchange changes
        const stockExchangeSelect = document.getElementById('stockExchange');
        if (stockExchangeSelect) {
            stockExchangeSelect.addEventListener('change', function() {
                const query = stockSymbolInput.value.trim();
                if (query.length >= 2) {
                    // Trigger search again with new exchange
                    stockSymbolInput.dispatchEvent(new Event('input'));
                }
            });
        }
    }
    
    // Add event listener for stock level dropdown to filter display
    const stockLevelStockSelect = document.getElementById('stockLevelStockSelect');
    if (stockLevelStockSelect) {
        stockLevelStockSelect.addEventListener('change', function() {
            const selectedStockKey = this.value;
            // If empty string, show all stocks; otherwise filter by selected stock
            renderAllStockLevels(selectedStockKey ? selectedStockKey : null);
        });
    }
});

// Dynamic Levels functionality
let bankNiftyPrice = 0;
let niftyPrice = 0;

// Store levels as arrays with UUIDs
let bankLevels = []; // Array of {uuid, value, stop_loss, target_percentage}
let niftyLevels = []; // Array of {uuid, value, stop_loss, target_percentage}

// Bank Nifty Functions - Dynamic Levels
function addBankLevel() {
    // Create a new empty level row
    const levelUuid = 'temp_' + Date.now();
    bankLevels.push({uuid: levelUuid, value: null, stop_loss: null, target_percentage: null});
    renderBankLevels();
}

function setBankLevel(uuid) {
    const levelIndex = bankLevels.findIndex(l => l.uuid === uuid);
    if (levelIndex === -1) return;
    
    const input = document.getElementById(`bankLevelInput_${uuid}`);
    const stopLossInput = document.getElementById(`bankStopLoss_${uuid}`);
    const targetInput = document.getElementById(`bankTarget_${uuid}`);
    
    const value = parseFloat(input.value);
    const stopLossPercentage = stopLossInput.value ? parseFloat(stopLossInput.value) : null;
    const targetPercentage = targetInput.value ? parseFloat(targetInput.value) : null;
    
    if (isNaN(value) || value <= 0) {
        alert('Please enter a valid positive entry price');
        return;
    }
    
    if (stopLossPercentage !== null && (isNaN(stopLossPercentage) || stopLossPercentage <= 0)) {
        alert('Please enter a valid positive stop loss percentage');
        return;
    }
    
    if (targetPercentage !== null && (isNaN(targetPercentage) || targetPercentage <= 0)) {
        alert('Please enter a valid positive target percentage');
        return;
    }
    
    const existingUuid = bankLevels[levelIndex].uuid.startsWith('temp_') ? null : bankLevels[levelIndex].uuid;
    bankLevels[levelIndex].value = value;
    bankLevels[levelIndex].stop_loss = stopLossPercentage;
    bankLevels[levelIndex].target_percentage = targetPercentage;
    
    // Save to database
    saveLevelToDatabase('BANK_NIFTY', value, existingUuid, stopLossPercentage, targetPercentage)
        .then(() => {
            console.log(`Bank Nifty Level set to: Entry=${value}, SL=${stopLossPercentage}%, Tgt=${targetPercentage}%`);
            renderBankLevels();
        })
        .catch(error => {
            alert('Error saving level: ' + error.message);
        });
}

function deleteBankLevel(uuid) {
    const levelIndex = bankLevels.findIndex(l => l.uuid === uuid);
    if (levelIndex === -1) return;
    
    const level = bankLevels[levelIndex];
    if (!level.value) {
        // Just remove from array if not saved yet
        bankLevels.splice(levelIndex, 1);
        renderBankLevels();
        return;
    }
    
    if (confirm(`Are you sure you want to delete this level (₹${level.value.toFixed(2)})?`)) {
        // If it's a temp UUID, just remove it
        if (uuid.startsWith('temp_')) {
            bankLevels.splice(levelIndex, 1);
            renderBankLevels();
            return;
        }
        
        // Call delete API
        fetch(`/levels/delete/${uuid}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                bankLevels.splice(levelIndex, 1);
                renderBankLevels();
                console.log('Bank Nifty Level deleted successfully');
            } else {
                alert('Error deleting level: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error deleting level: ' + error.message);
        });
    }
}

function clearBankLevels() {
    if (confirm('Are you sure you want to clear all Bank Nifty levels?')) {
        fetch('/levels/clear', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                index_type: 'BANK_NIFTY',
                today_only: false
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                bankLevels = [];
                renderBankLevels();
                alert(`Cleared ${data.deleted_count} level(s)`);
            } else {
                alert('Error clearing levels: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error clearing levels: ' + error.message);
        });
    }
}

function renderBankLevels() {
    const container = document.getElementById('bankLevelsContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    bankLevels.forEach((level, index) => {
        const levelDiv = document.createElement('div');
        levelDiv.className = 'border border-base-300 rounded-lg p-2 mb-2';
        levelDiv.innerHTML = `
            <div class="flex items-center gap-2">
                <div class="flex-1">
                    <label class="text-xs text-base-content/60 mb-1 block">Entry</label>
                    <input type="number" id="bankLevelInput_${level.uuid}" 
                           placeholder="Entry price" 
                           class="input input-bordered input-xs w-full" 
                           step="0.01" 
                           value="${level.value || ''}">
                </div>
                <div class="flex-1">
                    <label class="text-xs text-base-content/60 mb-1 block">SL %</label>
                    <input type="number" id="bankStopLoss_${level.uuid}" 
                           placeholder="Stop Loss %" 
                           class="input input-bordered input-xs w-full" 
                           step="0.1" 
                           value="${level.stop_loss || ''}">
                </div>
                <div class="flex-1">
                    <label class="text-xs text-base-content/60 mb-1 block">Tgt %</label>
                    <input type="number" id="bankTarget_${level.uuid}" 
                           placeholder="Target %" 
                           class="input input-bordered input-xs w-full" 
                           step="0.1" 
                           value="${level.target_percentage || ''}">
                </div>
                <div class="flex gap-1 pt-5">
                    <button class="btn btn-primary btn-xs px-2" onclick="setBankLevel('${level.uuid}')" title="Save">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                        </svg>
                    </button>
                    <button class="btn btn-error btn-xs px-2" onclick="deleteBankLevel('${level.uuid}')" title="Delete">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="flex items-center gap-2 text-xs mt-2" id="bankLevelInfo_${level.uuid}">
                <div class="flex-1 text-gray-600" id="bankLevelStatus_${level.uuid}">
                    ${level.value ? `Entry: ₹${level.value.toFixed(2)}` : 'Not set'}
                </div>
                <div class="text-gray-500" id="bankLevelDistance_${level.uuid}"></div>
            </div>
        `;
        container.appendChild(levelDiv);
    });
    
    // Update displays for all levels
    bankLevels.forEach(level => {
        updateBankLevelDisplay(level.uuid);
    });
}

function updateBankLevelDisplay(uuid) {
    const level = bankLevels.find(l => l.uuid === uuid);
    if (!level) return;
    
    const statusElement = document.getElementById(`bankLevelStatus_${uuid}`);
    const distanceElement = document.getElementById(`bankLevelDistance_${uuid}`);
    
    if (!statusElement || !distanceElement) return;
    
    if (level.value !== null) {
        let statusText = `Entry: ₹${level.value.toFixed(2)}`;
        if (level.stop_loss) {
            const stopLossPrice = level.value * (1 - level.stop_loss / 100);
            statusText += ` | SL: ₹${stopLossPrice.toFixed(2)} (${level.stop_loss}%)`;
        }
        if (level.target_percentage) {
            const targetPrice = level.value * (1 + level.target_percentage / 100);
            statusText += ` | Tgt: ₹${targetPrice.toFixed(2)} (${level.target_percentage}%)`;
        }
        statusElement.textContent = statusText;
        statusElement.className = 'text-xs text-gray-600';
        
        if (bankNiftyPrice > 0) {
            const distance = Math.abs(bankNiftyPrice - level.value);
            const distancePercent = (distance / level.value) * 100;
            distanceElement.textContent = `Distance: ₹${distance.toFixed(2)} (${distancePercent.toFixed(1)}%)`;
            
            // Color code based on distance
            if (distancePercent <= 1) {
                distanceElement.className = 'text-xs text-error font-semibold';
            } else if (distancePercent <= 5) {
                distanceElement.className = 'text-xs text-warning font-semibold';
            } else {
                distanceElement.className = 'text-xs text-gray-500';
            }
        } else {
            distanceElement.textContent = '';
        }
    } else {
        statusElement.textContent = 'Not set';
        statusElement.className = 'text-xs text-gray-600';
        distanceElement.textContent = '';
    }
}


// Nifty 50 Functions - Dynamic Levels
function addNiftyLevel() {
    // Create a new empty level row
    const levelUuid = 'temp_' + Date.now();
    niftyLevels.push({uuid: levelUuid, value: null, stop_loss: null, target_percentage: null});
    renderNiftyLevels();
}

function setNiftyLevel(uuid) {
    const levelIndex = niftyLevels.findIndex(l => l.uuid === uuid);
    if (levelIndex === -1) return;
    
    const input = document.getElementById(`niftyLevelInput_${uuid}`);
    const stopLossInput = document.getElementById(`niftyStopLoss_${uuid}`);
    const targetInput = document.getElementById(`niftyTarget_${uuid}`);
    
    const value = parseFloat(input.value);
    const stopLossPercentage = stopLossInput.value ? parseFloat(stopLossInput.value) : null;
    const targetPercentage = targetInput.value ? parseFloat(targetInput.value) : null;
    
    if (isNaN(value) || value <= 0) {
        alert('Please enter a valid positive entry price');
        return;
    }
    
    if (stopLossPercentage !== null && (isNaN(stopLossPercentage) || stopLossPercentage <= 0)) {
        alert('Please enter a valid positive stop loss percentage');
        return;
    }
    
    if (targetPercentage !== null && (isNaN(targetPercentage) || targetPercentage <= 0)) {
        alert('Please enter a valid positive target percentage');
        return;
    }
    
    const existingUuid = niftyLevels[levelIndex].uuid.startsWith('temp_') ? null : niftyLevels[levelIndex].uuid;
    niftyLevels[levelIndex].value = value;
    niftyLevels[levelIndex].stop_loss = stopLossPercentage;
    niftyLevels[levelIndex].target_percentage = targetPercentage;
    
    // Save to database
    saveLevelToDatabase('NIFTY_50', value, existingUuid, stopLossPercentage, targetPercentage)
        .then(() => {
            console.log(`Nifty Level set to: Entry=${value}, SL=${stopLossPercentage}%, Tgt=${targetPercentage}%`);
            renderNiftyLevels();
        })
        .catch(error => {
            alert('Error saving level: ' + error.message);
        });
}

function deleteNiftyLevel(uuid) {
    const levelIndex = niftyLevels.findIndex(l => l.uuid === uuid);
    if (levelIndex === -1) return;
    
    const level = niftyLevels[levelIndex];
    if (!level.value) {
        // Just remove from array if not saved yet
        niftyLevels.splice(levelIndex, 1);
        renderNiftyLevels();
        return;
    }
    
    if (confirm(`Are you sure you want to delete this level (₹${level.value.toFixed(2)})?`)) {
        // If it's a temp UUID, just remove it
        if (uuid.startsWith('temp_')) {
            niftyLevels.splice(levelIndex, 1);
            renderNiftyLevels();
            return;
        }
        
        // Call delete API
        fetch(`/levels/delete/${uuid}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                niftyLevels.splice(levelIndex, 1);
                renderNiftyLevels();
                console.log('Nifty Level deleted successfully');
            } else {
                alert('Error deleting level: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error deleting level: ' + error.message);
        });
    }
}

function clearNiftyLevels() {
    if (confirm('Are you sure you want to clear all Nifty 50 levels?')) {
        fetch('/levels/clear', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                index_type: 'NIFTY_50',
                today_only: false
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                niftyLevels = [];
                renderNiftyLevels();
                alert(`Cleared ${data.deleted_count} level(s)`);
            } else {
                alert('Error clearing levels: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error clearing levels: ' + error.message);
        });
    }
}

function renderNiftyLevels() {
    const container = document.getElementById('niftyLevelsContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    niftyLevels.forEach((level, index) => {
        const levelDiv = document.createElement('div');
        levelDiv.className = 'border border-base-300 rounded-lg p-2 mb-2';
        levelDiv.innerHTML = `
            <div class="flex items-center gap-2">
                <div class="flex-1">
                    <label class="text-xs text-base-content/60 mb-1 block">Entry</label>
                    <input type="number" id="niftyLevelInput_${level.uuid}" 
                           placeholder="Entry price" 
                           class="input input-bordered input-xs w-full" 
                           step="0.01" 
                           value="${level.value || ''}">
                </div>
                <div class="flex-1">
                    <label class="text-xs text-base-content/60 mb-1 block">SL %</label>
                    <input type="number" id="niftyStopLoss_${level.uuid}" 
                           placeholder="Stop Loss %" 
                           class="input input-bordered input-xs w-full" 
                           step="0.1" 
                           value="${level.stop_loss || ''}">
                </div>
                <div class="flex-1">
                    <label class="text-xs text-base-content/60 mb-1 block">Tgt %</label>
                    <input type="number" id="niftyTarget_${level.uuid}" 
                           placeholder="Target %" 
                           class="input input-bordered input-xs w-full" 
                           step="0.1" 
                           value="${level.target_percentage || ''}">
                </div>
                <div class="flex gap-1 pt-5">
                    <button class="btn btn-primary btn-xs px-2" onclick="setNiftyLevel('${level.uuid}')" title="Save">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                        </svg>
                    </button>
                    <button class="btn btn-error btn-xs px-2" onclick="deleteNiftyLevel('${level.uuid}')" title="Delete">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="flex items-center gap-2 text-xs mt-2" id="niftyLevelInfo_${level.uuid}">
                <div class="flex-1 text-gray-600" id="niftyLevelStatus_${level.uuid}">
                    ${level.value ? `Entry: ₹${level.value.toFixed(2)}` : 'Not set'}
                </div>
                <div class="text-gray-500" id="niftyLevelDistance_${level.uuid}"></div>
            </div>
        `;
        container.appendChild(levelDiv);
    });
    
    // Update displays for all levels
    niftyLevels.forEach(level => {
        updateNiftyLevelDisplay(level.uuid);
    });
}

function updateNiftyLevelDisplay(uuid) {
    const level = niftyLevels.find(l => l.uuid === uuid);
    if (!level) return;
    
    const statusElement = document.getElementById(`niftyLevelStatus_${uuid}`);
    const distanceElement = document.getElementById(`niftyLevelDistance_${uuid}`);
    
    if (!statusElement || !distanceElement) return;
    
    if (level.value !== null) {
        let statusText = `Entry: ₹${level.value.toFixed(2)}`;
        if (level.stop_loss) {
            const stopLossPrice = level.value * (1 - level.stop_loss / 100);
            statusText += ` | SL: ₹${stopLossPrice.toFixed(2)} (${level.stop_loss}%)`;
        }
        if (level.target_percentage) {
            const targetPrice = level.value * (1 + level.target_percentage / 100);
            statusText += ` | Tgt: ₹${targetPrice.toFixed(2)} (${level.target_percentage}%)`;
        }
        statusElement.textContent = statusText;
        statusElement.className = 'text-xs text-gray-600';
        
        if (niftyPrice > 0) {
            const distance = Math.abs(niftyPrice - level.value);
            const distancePercent = (distance / level.value) * 100;
            distanceElement.textContent = `Distance: ₹${distance.toFixed(2)} (${distancePercent.toFixed(1)}%)`;
            
            // Color code based on distance
            if (distancePercent <= 1) {
                distanceElement.className = 'text-xs text-error font-semibold';
            } else if (distancePercent <= 5) {
                distanceElement.className = 'text-xs text-warning font-semibold';
            } else {
                distanceElement.className = 'text-xs text-gray-500';
            }
        } else {
            distanceElement.textContent = '';
        }
    } else {
        statusElement.textContent = 'Not set';
        statusElement.className = 'text-xs text-gray-600';
        distanceElement.textContent = '';
    }
}

function updateBankNiftyPrice(price) {
    const previousPrice = bankNiftyPrice;
    bankNiftyPrice = price;
    const priceDisplay = document.getElementById('bankCurrentPriceDisplay');
    const timeDisplay = document.getElementById('bankPriceUpdateTime');
    if (priceDisplay) priceDisplay.textContent = `₹${price.toFixed(2)}`;
    if (timeDisplay) timeDisplay.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
    
    // Check for level breaches
    checkBankLevelBreaches(price, previousPrice);
    
    // Update all bank level displays
    bankLevels.forEach(level => {
        updateBankLevelDisplay(level.uuid);
    });
}

function updateNiftyPrice(price) {
    const previousPrice = niftyPrice;
    niftyPrice = price;
    const priceDisplay = document.getElementById('niftyCurrentPriceDisplay');
    const timeDisplay = document.getElementById('niftyPriceUpdateTime');
    if (priceDisplay) priceDisplay.textContent = `₹${price.toFixed(2)}`;
    if (timeDisplay) timeDisplay.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
    
    // Check for level breaches
    checkNiftyLevelBreaches(price, previousPrice);
    
    // Update all nifty level displays
    niftyLevels.forEach(level => {
        updateNiftyLevelDisplay(level.uuid);
    });
}

// Level breach detection functions
function checkBankLevelBreaches(currentPrice, previousPrice) {
    bankLevels.forEach((level, index) => {
        if (level.value !== null) {
            const breach = checkLevelBreach(currentPrice, previousPrice, level.value);
            
            if (breach.breached) {
                showBreachNotification('Bank Nifty', index + 1, level.value, currentPrice, breach.direction);
                updateBankLevelBreachStatus(level.uuid, breach);
            } else {
                updateBankLevelBreachStatus(level.uuid, { breached: false });
            }
        }
    });
}

function checkNiftyLevelBreaches(currentPrice, previousPrice) {
    niftyLevels.forEach((level, index) => {
        if (level.value !== null) {
            const breach = checkLevelBreach(currentPrice, previousPrice, level.value);
            
            if (breach.breached) {
                showBreachNotification('Nifty 50', index + 1, level.value, currentPrice, breach.direction);
                updateNiftyLevelBreachStatus(level.uuid, breach);
            } else {
                updateNiftyLevelBreachStatus(level.uuid, { breached: false });
            }
        }
    });
}

function checkLevelBreach(currentPrice, previousPrice, level) {
    if (!previousPrice || previousPrice === 0) {
        // No previous price data, can't determine crossing
        return { breached: false, direction: null };
    }
    
    // Check if price crossed the level
    const wasAbove = previousPrice > level;
    const isAbove = currentPrice > level;
    const wasBelow = previousPrice < level;
    const isBelow = currentPrice < level;
    
    // Determine if there was a crossing
    if (wasAbove && isBelow) {
        // Price crossed down through the level
        return { breached: true, direction: 'down' };
    } else if (wasBelow && isAbove) {
        // Price crossed up through the level
        return { breached: true, direction: 'up' };
    } else if (Math.abs(currentPrice - level) <= 0.01) {
        // Price is exactly at the level (within 0.01 tolerance)
        return { breached: true, direction: 'at_level' };
    }
    
    return { breached: false, direction: null };
}

function showBreachNotification(indexName, levelNumber, level, currentPrice, direction) {
    const directionText = direction === 'up' ? 'UP' : direction === 'down' ? 'DOWN' : 'AT';
    const directionColor = direction === 'up' ? 'text-success' : direction === 'down' ? 'text-error' : 'text-warning';
    
    console.log(`🚨 BREACH DETECTED: ${indexName} Level ${levelNumber} (₹${level.toFixed(2)}) crossed ${directionText} at ₹${currentPrice.toFixed(2)}`);
    
    // Create a visual notification
    const notification = document.createElement('div');
    notification.className = `alert alert-${direction === 'up' ? 'success' : direction === 'down' ? 'error' : 'warning'} mb-2`;
    notification.innerHTML = `
        <div class="flex items-center">
            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.5 0L4.268 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
            </svg>
            <div>
                <div class="font-semibold">${indexName} Level ${levelNumber} Breached!</div>
                <div class="text-sm">Level: ₹${level.toFixed(2)} | Price: ₹${currentPrice.toFixed(2)} | Direction: <span class="${directionColor} font-bold">${directionText}</span></div>
            </div>
        </div>
    `;
    
    // Add to alerts section or create a notifications area
    const alertsSection = document.querySelector('.card-body');
    if (alertsSection) {
        alertsSection.insertBefore(notification, alertsSection.firstChild);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 10000);
    }
}

function updateBankLevelBreachStatus(uuid, breach) {
    const statusElement = document.getElementById(`bankLevelStatus_${uuid}`);
    const distanceElement = document.getElementById(`bankLevelDistance_${uuid}`);
    
    if (!statusElement || !distanceElement) return;
    
    if (breach.breached) {
        const directionIcon = breach.direction === 'up' ? '↗️' : breach.direction === 'down' ? '↘️' : '⚡';
        const directionColor = breach.direction === 'up' ? 'text-success' : breach.direction === 'down' ? 'text-error' : 'text-warning';
        
        statusElement.innerHTML = `${directionIcon} BREACHED`;
        statusElement.className = `text-xs ${directionColor} font-bold animate-pulse`;
        
        distanceElement.textContent = `Direction: ${breach.direction.toUpperCase()}`;
        distanceElement.className = `text-xs ${directionColor} font-semibold`;
    } else {
        // Reset to normal display
        updateBankLevelDisplay(uuid);
    }
}

function updateNiftyLevelBreachStatus(uuid, breach) {
    const statusElement = document.getElementById(`niftyLevelStatus_${uuid}`);
    const distanceElement = document.getElementById(`niftyLevelDistance_${uuid}`);
    
    if (!statusElement || !distanceElement) return;
    
    if (breach.breached) {
        const directionIcon = breach.direction === 'up' ? '↗️' : breach.direction === 'down' ? '↘️' : '⚡';
        const directionColor = breach.direction === 'up' ? 'text-success' : breach.direction === 'down' ? 'text-error' : 'text-warning';
        
        statusElement.innerHTML = `${directionIcon} BREACHED`;
        statusElement.className = `text-xs ${directionColor} font-bold animate-pulse`;
        
        distanceElement.textContent = `Direction: ${breach.direction.toUpperCase()}`;
        distanceElement.className = `text-xs ${directionColor} font-semibold`;
    } else {
        // Reset to normal display
        updateNiftyLevelDisplay(uuid);
    }
}

// Database functions for three levels
function saveLevelToDatabase(indexType, levelValue, levelUuid = null, stopLossPercentage = null, targetPercentage = null) {
    return fetch('/levels/save', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            index_type: indexType,
            level_value: levelValue,
            uuid: levelUuid,
            stop_loss: stopLossPercentage,
            target_percentage: targetPercentage
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Level saved to database:', data.uuid);
            // Update UUID in the level object
            if (data.uuid) {
                if (indexType === 'BANK_NIFTY') {
                    const level = bankLevels.find(l => l.uuid.startsWith('temp_') || l.uuid === levelUuid);
                    if (level) {
                        level.uuid = data.uuid;
                        console.log('Updated Bank Nifty level UUID:', level);
                    }
                } else {
                    const level = niftyLevels.find(l => l.uuid.startsWith('temp_') || l.uuid === levelUuid);
                    if (level) {
                        level.uuid = data.uuid;
                        console.log('Updated Nifty level UUID:', level);
                    }
                }
            }
            return data;
        } else {
            console.error('Error saving level:', data.error);
            throw new Error(data.error || 'Failed to save level');
        }
    })
    .catch(error => {
        console.error('Error saving level:', error);
        throw error;
    });
}

function loadLevelsFromDatabase(todayOnly = false) {
    console.log('Loading levels from database...', todayOnly ? '(today only)' : '(all)');
    
    // Ensure containers exist before loading
    const bankContainer = document.getElementById('bankLevelsContainer');
    const niftyContainer = document.getElementById('niftyLevelsContainer');
    
    if (!bankContainer || !niftyContainer) {
        console.warn('Level containers not found, retrying in 100ms...');
        setTimeout(() => loadLevelsFromDatabase(todayOnly), 100);
        return;
    }
    
    const url = todayOnly ? '/levels/get?today_only=true' : '/levels/get';
    fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Levels API response:', data);
            if (data.success && data.levels) {
                // Load Bank Nifty levels (now as array)
                if (data.levels.BANK_NIFTY && Array.isArray(data.levels.BANK_NIFTY)) {
                    bankLevels = data.levels.BANK_NIFTY.map(level => ({
                        uuid: level.uuid,
                        value: level.value || level.level_value,
                        stop_loss: level.stop_loss || null,
                        target_percentage: level.target_percentage || null
                    }));
                    console.log(`Loaded ${bankLevels.length} Bank Nifty levels:`, bankLevels);
                } else {
                    console.log('No Bank Nifty levels found or invalid format');
                    bankLevels = [];
                }
                
                // Load Nifty 50 levels (now as array)
                if (data.levels.NIFTY_50 && Array.isArray(data.levels.NIFTY_50)) {
                    niftyLevels = data.levels.NIFTY_50.map(level => ({
                        uuid: level.uuid,
                        value: level.value || level.level_value,
                        stop_loss: level.stop_loss || null,
                        target_percentage: level.target_percentage || null
                    }));
                    console.log(`Loaded ${niftyLevels.length} Nifty 50 levels:`, niftyLevels);
                } else {
                    console.log('No Nifty 50 levels found or invalid format');
                    niftyLevels = [];
                }
                
                // Render the levels
                renderBankLevels();
                renderNiftyLevels();
                
                console.log('Levels loaded and rendered from database');
            } else {
                console.warn('API response missing success or levels:', data);
                // Initialize empty arrays if no data
                bankLevels = [];
                niftyLevels = [];
                renderBankLevels();
                renderNiftyLevels();
            }
        })
        .catch(error => {
            console.error('Error loading levels from database:', error);
            // Initialize empty arrays on error
            bankLevels = [];
            niftyLevels = [];
            renderBankLevels();
            renderNiftyLevels();
        });
}

// Paper Trades Functions
function loadPaperTrades() {
    // Get date filter value (defaults to today)
    const dateFilter = document.getElementById('paperTradesDateFilter')?.value || new Date().toISOString().split('T')[0];
    
    // Build query string
    const params = new URLSearchParams();
    if (dateFilter) {
        params.append('date', dateFilter);
    }
    
    fetch(`/trading/get-paper-trades?${params.toString()}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                renderPaperTrades(data.trades || [], data.date_filter);
            } else {
                showPaperTradesError(data.error || 'Failed to load paper trades');
            }
        })
        .catch(error => {
            console.error('Error loading paper trades:', error);
            showPaperTradesError('Error loading paper trades: ' + error.message);
        });
}

function renderPaperTrades(trades, dateFilter) {
    const container = document.getElementById('paperTradesContainer');
    if (!container) return;
    
    if (trades.length === 0) {
        const dateDisplay = dateFilter ? ` for ${new Date(dateFilter).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}` : '';
        container.innerHTML = `
            <div class="text-center text-base-content/60 py-8">
                <svg class="w-12 h-12 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                <p>No paper trades found${dateDisplay}</p>
            </div>
        `;
        return;
    }
    
    // Group trades by status
    const openTrades = trades.filter(t => t.status === 'OPEN');
    const closedTrades = trades.filter(t => t.status === 'CLOSED');
    
    let html = '';
    
    // Open Trades Section
    if (openTrades.length > 0) {
        html += `
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-3 flex items-center gap-2">
                    <span class="badge badge-success badge-lg">${openTrades.length}</span>
                    Open Trades
                </h3>
                <div class="overflow-x-auto">
                    <table class="table table-zebra w-full">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Type</th>
                                <th>Instrument</th>
                                <th>Qty</th>
                                <th>Entry Price</th>
                                <th>Current Price</th>
                                <th>Target</th>
                                <th>Stop Loss</th>
                                <th>P&L</th>
                                <th>Entry Time</th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        
        openTrades.forEach(trade => {
            const currentPrice = trade.current_price || 0;
            const entryPrice = trade.entry_price || 0;
            const pnl = currentPrice > 0 && entryPrice > 0 ? (currentPrice - entryPrice) * trade.quantity : 0;
            const pnlPercent = entryPrice > 0 ? ((currentPrice - entryPrice) / entryPrice) * 100 : 0;
            const pnlClass = pnl >= 0 ? 'text-success' : 'text-error';
            
            html += `
                <tr>
                    <td class="font-mono text-sm">${trade.tradingsymbol || 'N/A'}</td>
                    <td>
                        <span class="badge ${trade.option_type === 'CALL' ? 'badge-success' : 'badge-error'}">
                            ${trade.option_type || 'N/A'}
                        </span>
                    </td>
                    <td>${trade.instrument || 'N/A'}</td>
                    <td>${trade.quantity || 0}</td>
                    <td>₹${parseFloat(trade.entry_price || 0).toFixed(2)}</td>
                    <td>${currentPrice > 0 ? '₹' + parseFloat(currentPrice).toFixed(2) : 'N/A'}</td>
                    <td>₹${parseFloat(trade.target_price || 0).toFixed(2)}</td>
                    <td>₹${parseFloat(trade.stoploss_price || 0).toFixed(2)}</td>
                    <td class="${pnlClass} font-semibold">
                        ${currentPrice > 0 ? (pnl >= 0 ? '+' : '') + pnl.toFixed(2) + ' (' + (pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2) + '%)' : 'N/A'}
                    </td>
                    <td class="text-xs">${formatDateTime(trade.entry_time)}</td>
                </tr>
            `;
        });
        
        html += `
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    }
    
    // Closed Trades Section
    if (closedTrades.length > 0) {
        html += `
            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-3 flex items-center gap-2">
                    <span class="badge badge-lg">${closedTrades.length}</span>
                    Closed Trades
                </h3>
                <div class="overflow-x-auto">
                    <table class="table table-zebra w-full">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Type</th>
                                <th>Instrument</th>
                                <th>Qty</th>
                                <th>Entry Price</th>
                                <th>Exit Price</th>
                                <th>Exit Reason</th>
                                <th>P&L</th>
                                <th>Entry Time</th>
                                <th>Exit Time</th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        
        closedTrades.forEach(trade => {
            const pnl = trade.profit_loss || 0;
            const pnlPercent = trade.profit_loss_percent || 0;
            const pnlClass = pnl >= 0 ? 'text-success' : 'text-error';
            const exitReasonBadge = trade.exit_reason === 'TARGET' ? 'badge-success' : 
                                   trade.exit_reason === 'STOPLOSS' ? 'badge-error' : 'badge-warning';
            
            html += `
                <tr>
                    <td class="font-mono text-sm">${trade.tradingsymbol || 'N/A'}</td>
                    <td>
                        <span class="badge ${trade.option_type === 'CALL' ? 'badge-success' : 'badge-error'}">
                            ${trade.option_type || 'N/A'}
                        </span>
                    </td>
                    <td>${trade.instrument || 'N/A'}</td>
                    <td>${trade.quantity || 0}</td>
                    <td>₹${parseFloat(trade.entry_price || 0).toFixed(2)}</td>
                    <td>₹${parseFloat(trade.exit_price || 0).toFixed(2)}</td>
                    <td>
                        <span class="badge ${exitReasonBadge}">
                            ${trade.exit_reason || 'N/A'}
                        </span>
                    </td>
                    <td class="${pnlClass} font-semibold">
                        ${(pnl >= 0 ? '+' : '') + pnl.toFixed(2)} (${(pnlPercent >= 0 ? '+' : '') + pnlPercent.toFixed(2)}%)
                    </td>
                    <td class="text-xs">${formatDateTime(trade.entry_time)}</td>
                    <td class="text-xs">${formatDateTime(trade.exit_time)}</td>
                </tr>
            `;
        });
        
        html += `
                        </tbody>
                    </table>
                </div>
            </div>
        `;
    }
    
    container.innerHTML = html;
}

function showPaperTradesError(message) {
    const container = document.getElementById('paperTradesContainer');
    if (!container) return;
    
    container.innerHTML = `
        <div class="alert alert-error">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <span>${message}</span>
        </div>
    `;
}

function formatDateTime(dateTimeString) {
    if (!dateTimeString) return 'N/A';
    try {
        const date = new Date(dateTimeString);
        return date.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    } catch (e) {
        return dateTimeString;
    }
}

// Refresh button handler
document.addEventListener('DOMContentLoaded', function() {
    // Initialize date filter to today's date
    const dateFilterInput = document.getElementById('paperTradesDateFilter');
    if (dateFilterInput) {
        const today = new Date().toISOString().split('T')[0];
        dateFilterInput.value = today;
        
        // Add change event listener to reload trades when date changes
        dateFilterInput.addEventListener('change', function() {
            loadPaperTrades();
        });
    }
    
    const refreshBtn = document.getElementById('refreshPaperTrades');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', function() {
            const btn = this;
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<span class="loading loading-spinner loading-sm"></span> Refreshing...';
            btn.disabled = true;
            
            loadPaperTrades();
            
            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.disabled = false;
            }, 1000);
        });
    }
    
    // Load paper trades on page load
    loadPaperTrades();
    
    // Auto-refresh paper trades every 30 seconds
    setInterval(loadPaperTrades, 30000);
});
</script>
{% endblock %}